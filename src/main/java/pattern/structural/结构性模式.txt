结构型模式:通过改变代码结构来达到解耦的目的,使得代码容易维护和扩展
    1:代理模式: 提供了对目标对象额为的访问方式.即通过代理对象访问目标对象,这样可以在不修改原目标对象的前提下,
              提供额外的功能操作,扩展目标对象的功能
        1:静态代理: 这种代理方式需要代理对象和目标对象实现一样的接口
                   优点: 可以在不修改目标对象的前提下扩展目标对象的功能
                   缺点: 冗余,由于代理对象要实现与目标对象一致的接口,会产生过多的代理类
                        不易维护,一旦接口增加方法,目标对象和代理对象都要进行修改
        2:动态代理: 利用jdk的API,动态地在内存中构建代理对象,从而实现对目标对象的代理功能.动态代理又被称为jdk代理或接口代理
                   与静态代理的区别:
                        静态代理在编译时候就已经实现,编译完成后代理类是一个实际的class文件
                        动态代理是在运行时动态生成的,即在编译完成后没有实际的class文件,而是运行时动态的生成类字节码,并加载到jvm中
                   注: 代理目标对象必须实现接口,否则不能使用jdk的动态代理
                   主要涉及的jdk的类:
                        java.lang.reflect.Proxy
                        java.lang.reflect.InvocationHandler
        3:cglib代理 :是第三方代码生成库,运行时在内存中动态生成一个子类对象从而实现对目标对象的功能扩展
                     特点:
                        jdk的动态代理有一个限制,使用动态代理对象必须实现一个接口,如果想代理的类没有实现接口的类,就可以使用cglib
                        cglib是一个强大的高性能代码生成包,可以在运行期扩展java类实现java接口
                        cglib包底层使用一个小而块的字节码处理框架ASM,来转换字节码并生成新的类
                     cglib与jdk的动态代理最大的区别:
                        动态代理必须实现一个或多个接口,cglib不用
                        动态代理通过反射代理方法,比较消耗系统内存
                        cglib通过生成类字节码实现代理,比反射块,不存在性能问题,但是cglib会继承目标对象,需要重写方法,所以目标对象不能为final类


